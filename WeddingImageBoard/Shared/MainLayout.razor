@using System
@using Azure.Identity;
@using Azure.Storage.Blobs;
@using Azure.Storage.Blobs.Models;
@using Microsoft.AspNetCore.Components.Forms;
@using Microsoft.AspNetCore.Components.Web.Extensions;
@using System.Collections.Generic;
@using System.Net.Http.Json;
@using System.IO;
@using System.Linq;
@using System.Threading;
@using System.Threading.Tasks;
@using Microsoft.Extensions.Configuration;
@using WeddingImageBoard.InfiniteScrolling

@inject IConfiguration config
@inject IJSRuntime JSRuntime
@inject HttpClient Http
@inherits LayoutComponentBase

@if (showUploadPopup) {
    <div class="full-screen-flex">
        <div class="upload-popup">
            <input id="photoName" type="text" @bind="photoName" placeholder="Enter your name" class="name-input-box" />

            <label for="custom-file-upload" class="custom-file-upload">Browse Files</label>
            <InputFile @ref="inputFile" id="custom-file-upload" class="input-file-hidden" accept="image/*" Multiple MaxMessageSize="100000000" OnChange="HandleFileSelected"></InputFile>
            <div class="upload-progress-container" style="@(showProgressBar ? "display:block;" : "display:none;")">
                <div class="upload-progress" style="width:@(progressPercentage + "%")"></div>
            </div>
            <div class="upload-success-message" style="@(showSuccessMessage ? "display:block;" : "display:none;")">
                Upload Successful!
            </div>
            <div class="close-btn" @onclick="CloseUploadPopup">X</div>
        </div>
    </div>
}

@if (showImagePopup) {
    <div class="image-popup open">
        <div class="image-popup-content">
             <span class="image-close" @onclick="CloseImagePopup">×</span>
            <img src="@popupImageUrl" alt="Full-sized Image" />
        </div>
    </div>
}



<div class="background-col">
    <div class="main-container">
<div class="top-container">
    <div class="header-container">
        <h1>Welcome to the wedding of</h1>
        <h2>Mr. & Mrs. Rodriguez</h2>

        <!-- Show the upload popup when the button is clicked -->
        <button class="custom-button" @onclick="ShowUploadPopup">Upload Photos</button>

        <div class="background-image">
            <!-- This is where the pretty picture will be placed as a background -->
        </div>
    </div>
</div>
        <div class="border-line">
            </div>

        <div class="gallery-container">
            <InfiniteScrolling ItemsProvider="GetBlobItemsInChunks">
                <ItemTemplate Context="blobWithMetadata">
                    <div class="photo">
                        <img src="@GetBlobUri(blobWithMetadata.BlobItem.Name)"
                             alt="@blobWithMetadata.BlobItem.Name"
                             loading="lazy"
                        @onclick="() => OpenImagePopup(GetBlobUri(blobWithMetadata.BlobItem.Name))" />

                        @foreach (var metadata in blobWithMetadata.Metadata)
                        {
                            <div class="text-content">@metadata.Value</div>
                        }
                    </div>
                </ItemTemplate>
                <LoadingTemplate>
                    <div>Loading...</div>
                </LoadingTemplate>
            </InfiniteScrolling>
        </div>

</div>
</div>

@code {
    private bool showProgressBar = false;
    private bool showSuccessMessage = false;
    private int progressPercentage = 0;

    private InputFile inputFile;  // Reference to the InputFile component
    private List<BlobWithMetadata> blobItems = new List<BlobWithMetadata>();
    private bool showUploadPopup = false;
    private string photoName = "";
    private string popupImageUrl = null;
    private bool showImagePopup = false;

    private int currentPage = 1;
    private int itemsPerPage = 9;
    private List<BlobWithMetadata> displayedItems = new List<BlobWithMetadata>();
    private bool isLoading = false;
    private bool hasMoreItems = true;

    private Uri cachedBrowseSasUri;
    private DateTimeOffset? cachedBrowseSasUriFetchTime;



    private async Task<Uri> GetUploadSasUriFromFunction()
    {
        return await Http.GetFromJsonAsync<Uri>("https://weddingwebsitefunctions.azurewebsites.net/api/GetUploadBlobSAS");
    }

    private async Task<Uri> GetBrowseSasUriFromFunction()
    {
        // If the cachedBrowseSasUri is not null and it's less than 30 minutes old, return the cached version.
        if (cachedBrowseSasUri != null && cachedBrowseSasUriFetchTime.HasValue && DateTimeOffset.Now.Subtract(cachedBrowseSasUriFetchTime.Value).TotalMinutes < 30)
        {
            return cachedBrowseSasUri;
        }

        // Otherwise, fetch a new SAS URI
        cachedBrowseSasUri = await Http.GetFromJsonAsync<Uri>("https://weddingwebsitefunctions.azurewebsites.net/api/GetBrowseContainerSAS");

        // Update the fetch time
        cachedBrowseSasUriFetchTime = DateTimeOffset.Now;

        return cachedBrowseSasUri;
    }



    private void OpenImagePopup(string imageUrl)
    {
        popupImageUrl = imageUrl;
        showImagePopup = true;
    }

    private void CloseImagePopup()
    {
        showImagePopup = false;
    }

    // Show the upload popup
    private void ShowUploadPopup()
    {
        showUploadPopup = true;
    }

    // Close the upload popup
    private void CloseUploadPopup()
    {
        showUploadPopup = false;
        photoName = "";
        showSuccessMessage = false;
        progressPercentage = 0;
        StateHasChanged();
    }

    private async Task TriggerFileInput()
    {
        await JSRuntime.InvokeVoidAsync("triggerFilePicker");
    }

    // Handle the selected files
    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        showProgressBar = true;
        showSuccessMessage = false;
        StateHasChanged();  // Request a re-render

        var files = e.GetMultipleFiles().ToList();
        await UploadPhotosAsync(files);

        showProgressBar = false;
        showSuccessMessage = true;
        StateHasChanged();  // Request a re-render
        await Task.Delay(2000);

        CloseUploadPopup();
    }



    private async Task UploadPhotosAsync(List<IBrowserFile> files)
    {
        int totalFiles = files.Count;
        int uploadedFiles = 0;

        foreach (var file in files)
        {
            var buffer = new byte[file.Size];
            await file.OpenReadStream(maxAllowedSize: 1024 * 500000).ReadAsync(buffer);

            string reversedTimestamp = DateTimeOffset.UtcNow.Ticks.ToString("D19"); // This ensures it's always 19 characters, and newer dates have higher values.
            string blobName = reversedTimestamp + "-" + Guid.NewGuid().ToString() + Path.GetExtension(file.Name);

            // Get the SAS URI from the Azure Function
            Uri sasUri = await GetUploadSasUriFromFunction();

            BlobClient blobClient = new BlobClient(sasUri);
            var blobUploadOptions = new BlobUploadOptions
                {
                    HttpHeaders = new BlobHttpHeaders
                    {
                        CacheControl = "public, max-age=86400"  // Set Cache-Control to cache for 24 hours
                    }
                };

            using (var stream = new MemoryStream(buffer))
            {
                await blobClient.UploadAsync(stream, blobUploadOptions);
            }

            // Store the entered name as metadata
            var metadata = new Dictionary<string, string>
        {
            {"Name", photoName}
        };
            await blobClient.SetMetadataAsync(metadata);

            uploadedFiles++;
            progressPercentage = (int)((uploadedFiles / (float)totalFiles) * 100);
            StateHasChanged();
        }
    }


    private string GetBlobUri(string blobName)
    {
        string containerUri = "https://weddingphotoscr.blob.core.windows.net/weddingphotoscontainer/";
        return containerUri + blobName;
    }

    public class BlobWithMetadata
    {
        public BlobItem BlobItem { get; set; }
        public IDictionary<string, string> Metadata { get; set; }
        public DateTimeOffset? CreationTime { get; set; }
    }

    private async Task<IEnumerable<BlobWithMetadata>> GetBlobItemsInChunks(InfiniteScrollingItemsProviderRequest request)
    {
        var sasUri = await GetBrowseSasUriFromFunction();
        BlobContainerClient containerClient = new BlobContainerClient(sasUri);

        // Use built-in SDK pagination, get only the required page
        var blobResults = containerClient.GetBlobsAsync(BlobTraits.Metadata, BlobStates.All).AsPages(default, itemsPerPage);

        await foreach (var blobsPage in blobResults)
        {
            // If more pages available, hasMoreItems remains true
            hasMoreItems = blobsPage.ContinuationToken != null;


            var tasks = blobsPage.Values.Select(blobItem => FetchBlobMetadata(containerClient, blobItem)).ToList();

            // Execute tasks in parallel
            var results = await Task.WhenAll(tasks);

            // No need to sort; they are already in desired order due to blob naming strategy
            return results;
        }

        return Enumerable.Empty<BlobWithMetadata>();
    }


    private async Task<BlobWithMetadata> FetchBlobMetadata(BlobContainerClient containerClient, BlobItem blobItem)
    {
        BlobClient blobClient = containerClient.GetBlobClient(blobItem.Name);
        BlobProperties properties = await blobClient.GetPropertiesAsync();

        return new BlobWithMetadata
            {
                BlobItem = blobItem,
                Metadata = properties.Metadata,
                CreationTime = properties.CreatedOn
            };
    }


    protected override async Task OnInitializedAsync()
    {
        var request = new InfiniteScrollingItemsProviderRequest(0, CancellationToken.None); // Initialize with appropriate values
        await LoadItemsAsync(request);
    }


    private async Task OnScroll()
    {
        if (!isLoading && hasMoreItems)
        {
            // Create a new request with the start index and page size
            var request = new InfiniteScrollingItemsProviderRequest(displayedItems.Count, CancellationToken.None);

            await LoadItemsAsync(request);
        }
    }

    private async Task LoadItemsAsync(InfiniteScrollingItemsProviderRequest request)
    {
        if (!isLoading && hasMoreItems)
        {
            isLoading = true;
            var newItems = await GetBlobItemsInChunks(request);
            isLoading = false;

            if (newItems.Any())
            {
                displayedItems.AddRange(newItems);
            }

            StateHasChanged();
        }
    }


}
